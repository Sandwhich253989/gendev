from agents.project_manager.graph_router import construct_graph
from util.db_manager import connect_db
from agents.time.timestamp import get_timestamp
import json


def get_brd(proj_id, sqlite_conn):
    """
    Retrieves the Business Requirement Document (BRD) for a given project_id from the database.

    Args:
    - proj_id (int): Project ID for which BRD is to be fetched.

    Returns:
    - str: BRD content fetched from the database.
    """
    sqlite_cursor = sqlite_conn.cursor()
    try:
        sqlite_cursor.execute(f"SELECT brd FROM project WHERE project_id={proj_id}")
        result = sqlite_cursor.fetchone()  # Fetch the BRD content
        return result
    except Exception as e:
        raise e


def run_pm_agent(proj_id, assigned_to, sqlite_conn, llmtype, model):
    """
    Executes the project management graph process for a given project_id and assigned user.

    Args:
    - proj_id (int): Project ID for which the graph process is executed.
    - assigned_to (str): User assigned to handle the project.

    Returns:
    - str: Content generated by the graph process.
    """
    graph = construct_graph()  # Create the project management graph
    brd_content = get_brd(proj_id, sqlite_conn)  # Fetch BRD content for the project_id
    events = graph.stream({"messages": [("user", brd_content)], "llmtype": llmtype, "model": model},
                          stream_mode="values")

    # DEBUG
    for event in events:
        event["messages"][-1].pretty_print()  # Print the last message in each event

    store_plan(event["messages"][-1].content, assigned_to, proj_id,
               sqlite_conn)  # Store the generated plan in the database
    return event["messages"][-1].content  # Return the generated plan content


def store_plan(jplan, assigned_to, proj_id, sqlite_conn):
    """
    Stores the generated plan (JSON format) into the database.

    Args:
    - jplan (str): JSON formatted plan to be stored.
    - assigned_to (str): User assigned to handle the project.
    - proj_id (int): Project ID for which the plan is generated and stored.
    """
    try:
        sqlite_cursor = sqlite_conn.cursor()
        # Write the generated plan content to a JSON file for testing purposes
        file = open("agents/project_manager/plan.json", "w")
        file.write(jplan)
        file.close()

        jplan = json.loads(jplan)  # Load JSON plan string into Python dictionary
        sqlite_cursor.execute("SELECT task_id FROM task WHERE project_id=?", (proj_id,))
        result = sqlite_cursor.fetchall()
        task_ids = []
        for task_id in result:
            task_ids.append(task_id[0])
        current_time = get_timestamp()  # Get current timestamp using timestamp module

        if not task_ids:
            sqlite_cursor = sqlite_conn.cursor()
            for task in jplan["tasks"]:
                # Insert each task from the generated plan into the task table
                sqlite_cursor.execute(
                    "INSERT INTO task (task_id, project_id, task_description, estimate, status, "
                    "estimated_completion_time,"
                    "assigned_to, task_type) VALUES (?,?,?,?,?,?,?,?)",
                    (None, proj_id, task["task_description"], task["expected_completion_date"], "not completed",
                     task["estimated_time_completion_hrs"], assigned_to, task["task_type"])
                )
                sqlite_conn.commit()
        else:
            # Update existing row if task_id exists in code table
            ind = 0
            for task in jplan["tasks"]:
                sqlite_cursor.execute(
                    "UPDATE task SET task_description=?, estimate=?,status=?,estimated_completion_time=?,"
                    f"assigned_to=?,task_type=?, modified_date=? WHERE task_id={task_ids[ind]}",
                    (task["task_description"], task["expected_completion_date"], "not completed",
                     task["estimated_time_completion_hrs"], assigned_to, task["task_type"], current_time)
                )
                sqlite_conn.commit()
                ind += 1

    except Exception as e:
        raise e
    finally:
        sqlite_conn.close()
